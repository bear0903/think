<?php
/*
 * Created on 07.10.2005 by Tobias Demuth &lt;mailto: dev@tobiasdemuth.de&gt;
 * Copyright 2005 by Tobias Demuth
 *
 * This file is used for autoloading needed classes. It uses an autogenerated
 * php-file for caching already known classes and is able to crawl the project-
 * directory in order to find unknown ones.
 * It defines also an helping method, that is able to tell you, if a class
 * could be autoloaded on request or not.
 *
 * This Library is distributed under the GNU LGPL, which means (beside others):
 *
 *						NO WARRANTY
 *
 * 15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
 * WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
 * EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
 * OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
 * KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
 * LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
 * THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
 *
 * 16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
 * WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
 * AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
 * FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
 * LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
 * RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
 * FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
 * SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGES.
 *
 * The complete license should be part of your distribution, the file is just
 * named LICENSE. Read and acceppt it before using c^2! If you didn't get a
 * copy, view the license here: http://www.fsf.org/licensing/licenses/lgpl.txt
 */


// Initial Comment at the head of the file. Just a single line!
define ( 'CACHE_INIT_COMMENT', 'This is a caching-file. Do not change anything!' );

// Comment which should tell to which application the file belongs and
// when it was created
define ( 'CACHE_CREATED_COMMENT', 'Automatically created at %s by CacheClass Dennis' );

// The format of the creation date
// default produces dates like: 8th of October 2005, 16:25:31 pm
define ( 'CACHE_DATE_FORMAT', 'jS of F Y, h:i:s a' );

// The name of the caching file
// '.'.DIRECTORY_SEPARATOR.'TmpClassCache'.DIRECTORY_SEPARATOR.
///define ( 'CACHE_FILE_NAME',  $GLOBALS['config']['lib_dir'].DIRECTORY_SEPARATOR.'library'.DIRECTORY_SEPARATOR.'TmpClassCache'.DIRECTORY_SEPARATOR.'classCache.inc.php' );
//  update by bollyuan 2009-08-14
define ( 'CACHE_FILE_NAME', dirname(__FILE__).DIRECTORY_SEPARATOR.'TmpClassCache'.DIRECTORY_SEPARATOR.'classCache.inc.php' );

// Set this Constant to false and the Cache-File will be build every time,
// the variable $cache is changed. Setting this variable to false could slightly
// increase execution speed, if the $cache is rarely modified. On the other hand,
// a value of 'false' could delay script execution extremely if much new classes
// are added to the cache.
// Under Windows "true" won't work because register_shutdown_function doesn't work
// under MS Windows - check back php.net or zend.com for further details.
define ( 'REGISTER_SHUTDOWN_HOOK', true );

// Enter your filenaming-scheme here. @CLASS@ is a placeholder for the classname.
// Remove naming schemes that you do not use.
$filenameTemplates = array ("@CLASS@.php", "@CLASS@.class.php", "@CLASS@.inc.php", "i@CLASS@.php", "i@CLASS@.interface.php" );

### DO NOT CHANGE ANYTHING BEYOND THIS POINT ###
define ( 'CACHE_PHP_OPEN_TAG', '<?php' ); // No need to change
define ( 'CACHE_PHP_CLOSE_TAG', '?>' ); // No need to change
define ( 'CACHE_PHP_COMMENT_TAG', '#' ); // No need to change
define ( 'CACHE_NEW_LINE', "\n" ); // No need to change
define ( 'CACHE_TEMPLATE_START', '$cache = array(' ); // Change would break code!
define ( 'CACHE_TEMPLATE_END', ');' ); // Change would break code!


########### CODE_START #########################


// Initializes Cache-file. Should be necessary only at the first startup.
if (! file_exists ( CACHE_FILE_NAME )) {
	$cache = array ( );
	buildCacheFile ();
}

// This will make this script building a new Cache-File every time, the script
// shuts down.
if (REGISTER_SHUTDOWN_HOOK) {
	register_shutdown_function ( 'buildCacheFile' );
}

// Including the cache-file, so $cache is now known globally
require_once (CACHE_FILE_NAME);

// This function will be called every time a class cannot be found automatically by
// PHP. It checks first the cache, if the file of the needed class is already known.
// If it is not, the project-directory is crawled and the cache is updated.
// If the cache is out-of-date - means a found classfile seems not to exist - the
// project-directory is crawled too.
function __autoload($classname) {
	global $cache;
	// Cache lookup
	$file = lookupCache ( $classname );
	if ($file) {
		require_once ($file);
	}

	// Crawl directory and find the needed file
	$file = findfile ( getSupposedFilenames ( $classname ) );
	if ($file) {
		$cache [$classname] = $file; // Update cache
		if (! REGISTER_SHUTDOWN_HOOK) {
			buildCacheFile ();
		}
		require_once ($file); // include the found file
	}
}

// This function returns true, if either $classname is found in $cache or a file
// exists somewhere in the project-diectory, which looks like it could contain
// the searched class.
// The optional second parameter indicates if $cache should be updated, if a file
// that could contain the class is found in the project-directory, but not in
// $cache. It defaults to true.
function classCandidateExists($classname, $updateCache = true) {
	global $cache;

	if (lookupCache ( $classname )) {
		return true; // Found in cache
	}

	$file = findfile ( getSupposedFilenames ( $classname ) );
	if ($file) { // Found in project-directory
		if ($updateCache) {
			$cache [$classname] = $file; // Updating cache
			if (! REGISTER_SHUTDOWN_HOOK) {
				buildCacheFile ();
			}
		}

		return true;
	}

	return false; // Nothing found.
}

// Returns either the filename of the file corresponding to the class in the cache
// or false, if no or only an outdated entry exists. Outdated entries are removed.
function lookupCache($classname) {
	global $cache;

	if (isset ( $cache [$classname] )) {
		if (file_exists ( $cache [$classname] )) {
			return $cache [$classname]; // Return filename
		}

		// Cache is out-of-date, clear corrupted entry
		unset ( $cache [$classname] );
		if (! REGISTER_SHUTDOWN_HOOK) {
			buildCacheFile ();
		}
		return false;
	}// end if
}// end lookupCache()


// Returns the filenames that could contain the searched class, according to the
// above defined filename-templates.
function getSupposedFilenames($classname) {
	global $filenameTemplates;
	return str_replace ( "@CLASS@", $classname, $filenameTemplates );
}

// Crawls the directory, this file lays in, and all subdirectory for a file named
// as $file. If $file is an array, any of the overgiven file-names will be searched.
// This is meant for overgiving multiple possibilities how a file with a certain
// class in _could_ be named.
// For recursion-reasons there is a "hidden" second parameter which makes it
// possible to overgive the directory to start in.
function findFile($file) {
	// Normalizing the first parameter
	if (! is_array ( $file )) {
		$file = array ($file );
	}

	// Checking for the second, the "hidden" parameter
	// Used for recursion-reasons
	if (func_num_args () > 1) {
		$startDir = func_get_arg ( 1 );
	} else {
		$startDir = dirname ( __FILE__ );
	}

	$subDirectories = array ( );
	$dirIt = new DirectoryIterator ( $startDir );

	foreach ( $dirIt as $dirItem ) {
		if ($dirItem->isDot ()) {
			continue;
		}
		if ($dirItem->isDir ()) {
			$subDirectories [] = $dirItem->getPathname ();
			continue;
		}
		if (in_array ( $dirItem->getFilename (), $file )) {
			return $dirItem->getPathname ();
		}
	}

	foreach ( $subDirectories as $directory ) {
		$result = findfile ( $file, $directory );

		if ($result) {
			return $result;
		}
	}

	return false;
}

// Builds the cache-file out of the $cache-variable
function buildCacheFile() {
	global $cache;
	$createdComment = sprintf ( CACHE_CREATED_COMMENT, date ( CACHE_DATE_FORMAT ) );
	$file = fopen ( CACHE_FILE_NAME, "wb" );
	// Writing file-header
	$success = fwrite ( $file, CACHE_PHP_OPEN_TAG . CACHE_NEW_LINE . CACHE_NEW_LINE );
	fwrite ( $file, CACHE_PHP_COMMENT_TAG . " " . CACHE_INIT_COMMENT . CACHE_NEW_LINE );
	fwrite ( $file, CACHE_PHP_COMMENT_TAG . " " . $createdComment . CACHE_NEW_LINE );
	fwrite ( $file, CACHE_NEW_LINE );
	fwrite ( $file, CACHE_TEMPLATE_START . CACHE_NEW_LINE );

	// Write $cache to the file
	$i = 0;
	$cacheSize = count ( $cache );
	if($cacheSize>0) // add by dennis 2008-02-04
	{
		foreach ( $cache as $classname => $filename ) {
			fwrite ( $file, "\t'" . $classname . "' => '" . $filename . "'" );
				
			if ($i < $cacheSize - 1) {
				fwrite ( $file, ',' );
			}
			fwrite ( $file, CACHE_NEW_LINE );
				
			$i ++;
		}
	}

	// Writing file-footer
	fwrite ( $file, CACHE_TEMPLATE_END . CACHE_NEW_LINE . CACHE_NEW_LINE );
	fwrite ( $file, CACHE_PHP_CLOSE_TAG );
	fclose ( $file );
}
?>
